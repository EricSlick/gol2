Worklog
Eric Slick

Project: Game of Life 2

Note: Since I did this test three years ago, I decided that just re-submitting the old code was insufficient and I wanted
      to make something more than just the GOL, so I wanted to do the following to show something "better"

Goals:
 Implementation
   - recreate a cleaner and more efficient version of GOL compared with the last submission
   - implemented classic GOL visualized, but also...
   - add one or two new features to give a twist on the basic "game" revolving around this type of thing...
     - colonies
       - colonies that compete with other colonies
     - game
       - compete with the ai to see who's colony wins
       - there will be some kind of simple leveling up for the colony and cells
         - alter GOL base rules: death, birth, overcrowding
         - add "war" to concept...with competing colonies vying for survival
           - colony cell dies if it has more other colony cells adjacent (as if by war)
           - both cell dies if equal number of colony cells adjacent (as if by
           - leveling up can alter these rules such as when a cell dies
       - player and ai can make decisions on how to level up their colony
   - improve on the visual aspects of the last version.
   - improve the UI

 Testing
   - Use TDD with a BDD(ish) twist using rspec without a formal BDD tool
       note: this was inspired by a fellow programmer a couple years ago and thought to try it out again here.

Design
 Base
   - Implement Conway's Game of Life
 Extended
   - Implement competing cell groups (evolve the cells and implement some sort of attraction to keep them grouped
   - UI allows for realtime tweaks to the GOL and allow player competition against the computer

Tools
  - RubyMine 8.0.2
  - Ruby 2.3.4 [edit changed to 2.0.0 due to issues noted below)
  - rvm
  - git 2.6.3

---

Worklog

12/29/2015
  - thought through some ideas on what I could do to improve on old test

12/30/2015
  setup, prep and spiking
    - tried out gemstash (later removed due to potential issues as that it added no value to this project)
  - 4:45 Spiking Concepts (TL;DR stuff)
    - wanted to have a gem that could spawn multiple copies of the GOL
    - forking and communication with the fork
    - since this is an interest of mine I took far more time looking into this than I would have when doing a normal
      test.  I spent a lot of time looking to further my own understanding of forking and inter-process communications
      communications. However, I treated this like a spike to explore the viability of a specific solution and thought
      it would be a good thing to show how I approached this spike
      - basically, I just explored the various ways to do this: threading, forking, spawning, etc.
      - I considered the process to process communications that would be necessary
        - pipes, sockets, shared file, even redis
        - sockets seems to be superior to pipes with regards to Windows.
      - I dug deep into Process module and read a number of articles on the web, including this particularly useful
        one: http://allenlsy.com/working-with-unix-process-in-ruby/
      - Being able to set up a no-blocking child forks was a big win over simplifying controlling child processes safely
        since detaching them would make it necessary to implement more complicated coordination to ensure all processes
        exited safely
      - Spawn is worth future consideration.


  1/01/2015
  - Started with the Data structure
    - cells and their behaviors
    - did the easy stuff first, then stopped to consider the implications for "birthing" new cells
    - decided that every live cell would have all cells surrounding it defined but that "dead" cells wouldn't
      - this allows me to let every "live" cell know it's state without having to loop through all attached
        cells
      - I chose to base a cell on a single "pixel" instead of using a technique like hashlife since I wanted
        to add new/extended behavior's to each cell and that would explode the complexity of the hashlife approach.
    - I chose to use view the board as a grid like last time, but I would rather try implementing it without a grid
      which I think would add some interesting possibilities. Nearby cells would be based on distance rather than
      an 8 compass grid.  But for simplicity and to maintain some control over this project, grids is the way I went
    - I chose to create cells only when needed and never destroy (but recycle) them to reduce the load on the GC

  1/02/2015
    - finished cell structure at this point
      - every live cell has all cells defined around it (alive or dead)
      - refactored cells significantly at this point

  1/03/2015
    - Finished up Cell refactor and basic GOL rules
    - With data structure finished, I decided to create the game from this point from the user's perspective
    - Researched 2D graphics gems and it came down to Gosu again and a new one ruby2d.
      - ruby2d offers some interesting possibilities but had issues installing it successfully
      - gosu proved problematic too
      - spent a great deal of time trying to get either of these gems to work.
    - Added Gosu gem for visualization on a computer screen
      - major problems getting Gosu to install
        - needed to uninstall rvm, install brew, then re-install rvm, so brew was in its default location
        - brew install sdl2
        - then was able to install the gosu gem.
        - now a segmentation fault issue
  1/04/2015
    - I finally figured out that bundler,rspec 3, gosu, gemstash(maybe) and ruby 2.1.x and 2.2.x simply didn't play
      well together: seg faults, inability to bundle.
    - ruby 2.0 did the trick, removed gemstash as it was not adding anything anyway, just something fun to play with.















